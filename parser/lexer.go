//line parser/lexer.go:2
//line parser/lexer.l:33
package parser

import (
    "fmt"
    "io"
    "log"
    "os"
    "math"
    "strconv"
    "strings"
    "unicode/utf8"

    "github.com/VirusTotal/gyp/ast"
    "github.com/VirusTotal/gyp/hex"
    gyperror "github.com/VirusTotal/gyp/error"
)

type YYcontext struct {
    Token     string
}

// YYtype is a structure that represents a token. The lexer/scanner returns an
// instance of this structure every time parser asks for the next token. Each
// token may have an associated value, for example, the _IDENTIFIER_ token has
// an associated string with the identifier's name. If the lexer/scanner wants
// to return an error to the parser it sets the Error field and leaves the
// Token and Value empty. This structure also stores information about the
// token's position within the original source code.
type YYtype struct {
  Token    int  // One of the constants defined in grammar.y via the %token directive.
  Lineno   int  // Line number where the token is found.
  StartPos int  // Position within the parsed source code where the token starts (inclusive).
  EndPos   int  // Position within the parsed source code where the token ends (exclusive).
  Value    *yrSymType // Value associated with the toke.
  Error    gyperror.Error
}

// Token creates a YYtype struct for the given token type with no associated
// value.
func (s *Scanner) Token(tokenType int) YYtype {
  return YYtype{
    Token: tokenType,
    Lineno: s.Lineno,
    StartPos: s.textPtr,
    EndPos: s.textPtr + len(s.Context.Token)}
}

// TokenString creates a YYtype struct for the given token type with an
// associated string.
func (s *Scanner) TokenString(tokenType int, v string) YYtype {
  t := s.Token(tokenType)
  t.Value = &yrSymType{s: v}
  return t
}

func (s *Scanner) TokenInt64(tokenType int, v int64) YYtype {
  t := s.Token(tokenType)
  t.Value = &yrSymType{i64: v}
  return t
}

func (s *Scanner) TokenFloat64(tokenType int, v float64) YYtype {
  t := s.Token(tokenType)
  t.Value = &yrSymType{f64: v}
  return t
}

func (s *Scanner) TokenRegExp(reg *ast.LiteralRegexp) YYtype {
  t := s.Token(_REGEXP_)
  t.Value = &yrSymType{reg: reg}
  return t
}

func (s *Scanner) TokenHexString(hexTokens []ast.HexToken) YYtype {
  t := s.Token(_HEX_STRING_)
  t.Value = &yrSymType{hexTokens: hexTokens}
  return t
}

func Error(c gyperror.Code, msg string) YYtype {
  return YYtype{Error: gyperror.Error{c, msg, 0,}}
}

func validateAscii(s string) error {
  for i := 0; i < len(s); i++ {
    if s[i] < 32 || s[i] >= 127 {
       return fmt.Errorf(`invalid ASCII character "\x%02x"`, s[i])
    }
  }
  return nil
}

func validateUTF8(s string) error {
  for index, rune := range s {
    if rune == utf8.RuneError {
        return fmt.Errorf(`invalid UTF-8 character "\x%02x"`, s[index])
    }
  }
  return nil
}

// The YY_USER_DATA macro is used to define variables inside the Scanner
// Lex() method. These variables manage buffers for gathering groups of
// tokens. Flex collects tokens individually but strings and conditions may
// contain several tokens.
// Two different buffers are necessary because conditions may contain strings.

// This comment applies to the YY_USER_ACTION macro, which is having
// a problem with comments...
// For condition, the colons and whitespace will be collected in the
// prefix and the right brace for the suffix. Use strings.TrimLeft/Right



//line parser/lexer.go:118

// START OF SKELL ------------------------------------------------------
// A lexical scanner generated by flexgo

type Scanner struct {
	In   io.Reader
	Out  io.Writer
	Lineno int

	Filename      string
	Wrap          func(*Scanner) bool
	IsInteractive func(io.Reader) bool
	Context       YYcontext

	lastAcceptingState   int
	lastAcceptingCpos    int
	debug                bool
	start                int
	stateBuf             []int
	statePtr             int
	fullState            int
	fullMatch            int
	fullLp               int
	lp                   int
	lookingForTrailBegin int
	holdChar             byte
	cBufP                int
	didBufferSwitchOnEof bool
	textPtr              int
	nChars               int
	init                 bool
	moreFlag             bool
    moreLen              int

	// buffer
	inputFile    io.Reader
	chBuf        []byte // input buffer
	bufPos       int    // current position in input buffer
	bufSize      int
	bufNChars    int
	Interactive  bool
	atBol        int // 0 (false) or 1 (true)
	fillBuffer   bool
	bufferStatus int
}

func NewScanner() *Scanner {
	yy := Scanner{
		Lineno: 1,
		In:            os.Stdin,
		Out:           os.Stdout,
		Wrap:          func(yyy *Scanner) bool { return true },
		IsInteractive: func(file io.Reader) bool { return yyInteractiveDefault },
		bufSize:       yyBufSize,
		chBuf:         make([]byte, yyBufSize+2),
		start:         1,
		stateBuf:      make([]int, yyBufSize+2),
		atBol:         1,
		debug:         yyFlexDebug,
		fillBuffer:    true,
	}
	return &yy
}

func (yy *Scanner) NewFile() {
	yy.Restart(yy.In)
}

const yyEndOfBufferChar = 0

const yyBufSize = 32768

const (
	eobActEndOfFile    = 0
	eobActContinueScan = 1
	eobActLastMatch    = 2
)

const (
	yyBufferNew        = 0
	yyBufferNormal     = 1
	yyBufferEofPending = 2
)

// [1.0] the user's section 1 definitions and yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here
/* Begin user sect3 */
const yyFlexDebug = false

const yyInteractiveDefault = false
// SKEL ----------------------------------------------------------------

// [1.5] DFA------------------------------------------------------------
// SKEL ----------------------------------------------------------------

// [4.0] data tables for the DFA go here -------------------------------
const yyNumRules = 84
const yyEndOfBuffer = 85
var yyAccept = [288]int16{   0,
        0,    0,    0,    0,    0,    0,    0,    0,   85,   83,
       82,   82,   57,   79,   55,   54,   83,   80,   60,   60,
        2,   83,    3,   56,   59,   59,   59,   59,   59,   59,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
       59,   59,   59,   83,   71,   72,   64,   84,   77,   78,
       74,   84,   51,   51,   57,    7,   55,   53,   54,    1,
       49,   52,    0,   60,    0,    0,    0,    0,    8,    4,
        6,    5,    9,   56,   59,   59,   59,   59,   28,   59,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
       59,   29,   59,   59,   59,   59,   30,   27,   59,   59,

       59,   59,   59,   59,   59,   59,    0,    0,   71,   73,
       68,   69,   67,   66,   65,   73,   77,   74,   74,   76,
       75,   50,   52,   61,   60,   63,   62,   33,   26,   34,
       59,   59,   59,   59,   59,   59,   59,   59,   32,   59,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
       59,   59,   25,   59,   59,   59,   59,   59,   59,   59,
       59,   19,   81,    0,    0,    0,   59,   59,   59,   59,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
       59,   59,   59,   59,   58,   59,   59,   13,   59,   35,
       59,   12,   59,   59,   31,   23,   18,    0,    0,    0,

        0,   70,   15,   59,   59,   59,   59,   59,   59,   24,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
       59,   59,   59,   59,   59,   16,   59,   59,   59,   59,
       59,   59,   59,   11,   59,   59,   59,   46,   59,   58,
       59,   59,   21,   59,   59,   59,   59,   59,   59,   48,
       59,   59,   59,   59,   59,   59,   45,   47,   59,   38,
       10,   59,   14,   59,   59,   39,   43,   59,   37,   20,
       59,   59,   59,   59,   59,   22,   59,   40,   44,   59,
       59,   17,   36,   59,   41,   42,    0,
    }

var yyEc = [256]byte{    0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    4,    5,    6,    7,    1,    1,    1,    8,
        8,    9,    1,    1,    8,   10,   11,   12,   13,   14,
       15,   16,   17,   18,   17,   19,   20,    1,    1,   21,
       22,   23,    8,   24,   25,   26,   25,   25,   25,   25,
       27,   27,   27,   27,   28,   27,   29,   27,   27,   27,
       27,   27,   27,   27,   27,   27,   27,   27,   27,   27,
        8,   30,    8,    1,   31,    1,   32,   33,   34,   35,

       36,   37,   38,   39,   40,   27,   27,   41,   42,   43,
       44,   45,   46,   47,   48,   49,   50,   51,   52,   53,
       54,   55,   56,    8,   57,    8,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,
    }

var yyMeta = [58]byte{    0,
        1,    2,    3,    1,    4,    1,    1,    2,    5,    6,
        7,    8,    8,    8,    8,    8,    8,    8,    8,    8,
        1,    9,    1,    1,   10,   10,   11,   12,   12,   13,
       11,   10,   10,   10,   10,   10,   10,   11,   11,   11,
       11,   11,   11,   12,   11,   11,   11,   11,   11,   11,
       11,   11,   12,   11,   11,    1,    1,
    }

var yyBase = [309]uint16{   0,
        0,    0,   55,   56,   59,   60,  468,  467,  475,  478,
      478,  478,  452,  478,    0,  464,  462,   55,   55,   59,
       46,  449,   50,    0,    0,   33,  438,  425,  432,  424,
       60,  425,   59,   43,  421,   59,  417,  413,  413,   58,
      421,  420,  415,  447,    0,  478,  478,   86,    0,  478,
       69,  446,  478,  445,  433,  478,    0,  478,  445,  478,
      478,    0,    0,    0,  427,  426,  106,    0,  478,  478,
      478,  478,  478,    0,    0,  410,   59,  416,    0,  401,
      405,  410,   76,  405,  404,  397,  402,  398,  397,   34,
      395,   81,  390,  389,  388,   93,    0,    0,  396,  394,

       94,  398,  383,  389,  396,  383,   87,  123,    0,  478,
      478,  478,  478,  478,  478,    0,    0,  381,  478,  478,
      478,  478,    0,    0,  478,  133,    0,    0,    0,    0,
      388,  391,   79,  386,  377,  377,  375,  386,    0,  380,
      387,  376,  383,  367,  372,  374,  139,  382,  379,  380,
      379,  374,    0,  358,  372,  360,  366,  363,  368,  354,
      366,    0,  478,  392,  397,    0,  359,  380,  357,  364,
      352,  342,  339,  356,  343,  338,  357,  339,  339,  354,
      338,  334,  365,  368,  348,  333,  340,    0,  330,    0,
      345,    0,  327,  332,    0,    0,    0,  365,  129,  370,

      120,  478,    0,  356,  322,  330,  333,  328,  322,    0,
      326,  321,  323,  331,  310,  320,  311,  324,  321,  279,
      289,  277,  251,  244,  250,  212,  223,  216,  221,  206,
      210,  193,  196,    0,  200,  199,  190,    0,  200,    0,
      183,  181,    0,  192,  171,  128,  135,  130,  125,    0,
      133,  131,  134,  134,  125,  118,    0,    0,  114,    0,
        0,  125,    0,  129,  120,    0,    0,  119,    0,    0,
      113,  121,  119,  108,  120,    0,  106,    0,    0,  104,
      104,    0,    0,   98,    0,    0,  478,  177,  190,  203,
      209,  214,  222,  229,  234,  239,  250,  260,  272,  285,

      297,  310,   70,  316,  319,  329,  342,  348,
    }

var yyDef = [309]int16{   0,
      287,    1,  288,  288,  289,  289,  290,  290,  287,  287,
      287,  287,  291,  287,  292,  293,  287,  287,  294,  294,
      287,  287,  287,  295,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  297,  298,  287,  287,  299,  300,  287,
      287,  301,  287,  287,  291,  287,  292,  287,  293,  287,
      287,  302,  303,   20,  287,  287,  287,  304,  287,  287,
      287,  287,  287,  295,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,

      296,  296,  296,  296,  296,  296,  297,  287,  298,  287,
      287,  287,  287,  287,  287,  305,  300,  287,  287,  287,
      287,  287,  302,  303,  287,  287,  304,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  287,  306,  307,  308,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  306,  306,  307,

      297,  287,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,  296,  296,  296,  296,
      296,  296,  296,  296,  296,  296,    0,  287,  287,  287,
      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,

      287,  287,  287,  287,  287,  287,  287,  287,
    }

var yyNxt = [536]uint16{   0,
       10,   11,   12,   13,   14,   15,   16,   10,   10,   17,
       18,   19,   20,   20,   20,   20,   20,   20,   20,   20,
       21,   22,   23,   24,   25,   25,   25,   25,   25,   10,
       25,   26,   27,   28,   29,   30,   31,   32,   25,   33,
       25,   34,   35,   36,   37,   25,   38,   39,   40,   41,
       25,   42,   43,   25,   25,   44,   10,   46,   46,   47,
       47,   50,   50,   61,   63,   62,   69,   70,   63,   51,
       51,   72,   73,   76,   94,   77,  143,  124,   95,  144,
       78,   79,   65,   66,   48,   48,   65,   66,   52,   52,
      111,   84,   89,  129,   90,   97,  102,  108,   67,   85,

       91,   92,  287,   86,  103,   98,   93,   68,  118,   87,
      135,  287,  130,  169,  146,  112,  119,  126,  126,  126,
      126,  126,  126,  126,  136,  156,  151,  170,  113,  147,
      108,  164,  114,  165,  115,  152,  286,  199,  116,  107,
      157,  153,  285,  163,  126,  126,  126,  126,  126,  126,
      126,  183,  284,  184,  283,  282,  281,  185,  280,  279,
      278,  277,  276,  275,  274,  273,  272,  271,  270,  269,
      268,  267,  266,  265,  264,  263,  163,   45,   45,   45,
       45,   45,   45,   45,   45,   45,   45,   45,   45,   45,
       49,   49,   49,   49,   49,   49,   49,   49,   49,   49,

       49,   49,   49,   53,   53,   53,   53,   53,   53,   53,
       53,   53,   53,   53,   53,   53,   55,   55,   55,   55,
       55,   57,  262,   57,   57,   57,   59,  261,  260,   59,
      259,   59,   59,   59,   64,  258,   64,  257,  256,  255,
       64,   74,  254,   74,   74,   74,   75,  253,   75,   75,
       75,  107,  107,  252,  251,  250,  107,  107,  249,  107,
      109,  109,  248,  247,  109,  109,  109,  109,  109,  109,
      109,  109,  110,  110,  110,  110,  110,  110,  110,  110,
      110,  110,  110,  110,  110,  117,  117,  246,  117,  117,
      117,  245,  117,  117,  117,  117,  117,  120,  120,  244,

      120,  120,  120,  120,  120,  120,  120,  120,  120,  120,
      123,  123,  243,  123,  123,  123,  123,  123,  123,  123,
      123,  123,  123,  127,  242,  127,  166,  241,  166,  198,
      198,  198,  198,  198,  198,  198,  198,  198,  198,  198,
      198,  198,  200,  200,  200,  200,  200,  200,  200,  200,
      200,  200,  200,  200,  200,  202,  240,  202,  239,  238,
      237,  236,  235,  234,  233,  232,  231,  230,  229,  228,
      227,  226,  201,  199,  225,  224,  223,  222,  221,  220,
      219,  185,  185,  218,  217,  216,  215,  214,  213,  212,
      211,  210,  209,  208,  207,  206,  205,  204,  203,  201,

      199,  197,  147,  196,  195,  194,  193,  192,  191,  190,
      189,  188,  187,  186,  182,  181,  180,  179,  178,  177,
      176,  175,  174,  173,  172,  171,  168,  167,  119,  162,
      161,  160,  159,  158,  155,  154,  150,  149,  148,  145,
      142,  141,  140,  139,  138,  137,  134,  133,  132,  131,
      128,  125,  125,   58,  287,  122,  121,  108,  106,  105,
      104,  101,  100,   99,   96,   88,   83,   82,   81,   80,
       71,   60,   58,   56,  287,   54,   54,    9,  287,  287,
      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,
      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,

      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,
      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,
      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,
      287,  287,  287,  287,  287,
    }

var yyChk = [536]int16{   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    3,    4,    3,
        4,    5,    6,   18,   19,   18,   21,   21,   20,    5,
        6,   23,   23,   26,   34,   26,   90,  303,   34,   90,
       26,   26,   19,   19,    3,    4,   20,   20,    5,    6,
       48,   31,   33,   77,   33,   36,   40,  107,   19,   31,

       33,   33,   20,   31,   40,   36,   33,   19,   51,   31,
       83,   20,   77,  133,   92,   48,   51,   67,   67,   67,
       67,   67,   67,   67,   83,  101,   96,  133,   48,   92,
      201,  108,   48,  108,   48,   96,  284,  199,   48,  199,
      101,   96,  281,  107,  126,  126,  126,  126,  126,  126,
      126,  147,  280,  147,  277,  275,  274,  147,  273,  272,
      271,  268,  265,  264,  262,  259,  256,  255,  254,  253,
      252,  251,  249,  248,  247,  246,  201,  288,  288,  288,
      288,  288,  288,  288,  288,  288,  288,  288,  288,  288,
      289,  289,  289,  289,  289,  289,  289,  289,  289,  289,

      289,  289,  289,  290,  290,  290,  290,  290,  290,  290,
      290,  290,  290,  290,  290,  290,  291,  291,  291,  291,
      291,  292,  245,  292,  292,  292,  293,  244,  242,  293,
      241,  293,  293,  293,  294,  239,  294,  237,  236,  235,
      294,  295,  233,  295,  295,  295,  296,  232,  296,  296,
      296,  297,  297,  231,  230,  229,  297,  297,  228,  297,
      298,  298,  227,  226,  298,  298,  298,  298,  298,  298,
      298,  298,  299,  299,  299,  299,  299,  299,  299,  299,
      299,  299,  299,  299,  299,  300,  300,  225,  300,  300,
      300,  224,  300,  300,  300,  300,  300,  301,  301,  223,

      301,  301,  301,  301,  301,  301,  301,  301,  301,  301,
      302,  302,  222,  302,  302,  302,  302,  302,  302,  302,
      302,  302,  302,  304,  221,  304,  305,  220,  305,  306,
      306,  306,  306,  306,  306,  306,  306,  306,  306,  306,
      306,  306,  307,  307,  307,  307,  307,  307,  307,  307,
      307,  307,  307,  307,  307,  308,  219,  308,  218,  217,
      216,  215,  214,  213,  212,  211,  209,  208,  207,  206,
      205,  204,  200,  198,  194,  193,  191,  189,  187,  186,
      185,  184,  183,  182,  181,  180,  179,  178,  177,  176,
      175,  174,  173,  172,  171,  170,  169,  168,  167,  165,

      164,  161,  160,  159,  158,  157,  156,  155,  154,  152,
      151,  150,  149,  148,  146,  145,  144,  143,  142,  141,
      140,  138,  137,  136,  135,  134,  132,  131,  118,  106,
      105,  104,  103,  102,  100,   99,   95,   94,   93,   91,
       89,   88,   87,   86,   85,   84,   82,   81,   80,   78,
       76,   66,   65,   59,   55,   54,   52,   44,   43,   42,
       41,   39,   38,   37,   35,   32,   30,   29,   28,   27,
       22,   17,   16,   13,    9,    8,    7,  287,  287,  287,
      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,
      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,

      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,
      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,
      287,  287,  287,  287,  287,  287,  287,  287,  287,  287,
      287,  287,  287,  287,  287,
    }

/* Table of booleans, true if rule could match eol. */
var yyRuleCanMatchEol = [85]int32{   0,
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 
    0, 1, 1, 0, 0,     };

//line parser/lexer.l:1
/*
Copyright (c) 2007-2013. The YARA Authors. All Rights Reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation and/or
other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors
may be used to endorse or promote products derived from this software without
specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* Lexical analyzer for YARA */

//line parser/lexer.l:147
 

 

 

// Define a constant for end-of-file
const eof = 0



//line parser/lexer.go:539
// SKEL ----------------------------------------------------------------

const yyInitial  = 0
const STR = 1
const REGEXP = 2
const COMMENT = 3

const yyReadBufSize = 16384

func (yy *Scanner) input(offset, maxRead int) int {

// [5.0] fread()/read() definition of yy_INPUT goes here ---------------
// nothing here, all moved to skeleton
// SKEL ----------------------------------------------------------------

	if yy.Interactive {
		b := make([]byte, 1)
		var n int
		for n = 0; n < maxRead; n++ {
			nn, err := yy.inputFile.Read(b)
			if err != nil && err != io.EOF {
				log.Panicln("Reading 1 byte:", err)
			}
			if nn < 1 {
				break
			}
			yy.chBuf[offset+n] = b[0]
			if b[0] == '\n' {
				n++
				break
			}
		}
		return n
	}

	n, err := yy.inputFile.Read(yy.chBuf[offset:offset+maxRead])
	if err != nil  && err != io.EOF {
		log.Panicf("Reading %d bytes: %v\n", maxRead, err)
	}
	return n
}

/* [6.0] YY_RULE_SETUP definition goes here --------------------------*/

// SKEL ----------------------------------------------------------------

// The main scanner function which does all the work.
func (yy *Scanner) Lex() YYtype {
	var yyCurrentState int
	var yyBp, yyCp int
	var yyAct int
	var yytext []byte
	var yyleng int
	var yylineno int
	_ = yytext
	_ = yyleng
	_ =  yylineno 

	var (
    str      []byte
    regexp   []byte
  )

	if !yy.init {
		yy.init = true
		// code to run inside Lex() when it is called the first time

		if yy.In == nil {
			yy.In = os.Stdin
		}
		if yy.Out == nil {
			yy.Out = os.Stdout
		}
		yy.initBuffer(yy.In)
		yy.loadBufferState()
	}

	yyout := yy.Out
	_ = yyout

// [7.0] user's declarations go here -----------------------------------
//line parser/lexer.l:185


//line parser/lexer.go:624
// SKEL ----------------------------------------------------------------

	for { // loops until end-of-file is reached

// [8.0] yy''more-related code goes here -------------------------------
// SKEL ----------------------------------------------------------------

		yyCp = yy.cBufP

		/* Support of yytext. */
		yy.chBuf[yyCp] = yy.holdChar

		// yyBp points to the position in yy_ch_buf of the start of
		// the current run.
		yyBp = yyCp

// [9.0] code to set up and find next match goes here ------------------
		yyCurrentState = yy.start
yyMatch:
		for {
			yyC := int(yyEc[yy.chBuf[yyCp]])
						if yyAccept[yyCurrentState] != 0 {
				yy.lastAcceptingState = yyCurrentState
				yy.lastAcceptingCpos = yyCp
			}
			for int(yyChk[int(yyBase[yyCurrentState])+yyC]) != yyCurrentState {
				yyCurrentState = int(yyDef[yyCurrentState])
				if yyCurrentState >= 288 {
					yyC = int(yyMeta[yyC])
				}
			}
			yyCurrentState = int(yyNxt[int(yyBase[yyCurrentState])+yyC])
			yyCp++
			if yyCurrentState == 287 {
				break
			}
		}
		yyCp = yy.lastAcceptingCpos
		yyCurrentState = yy.lastAcceptingState
// SKEL ----------------------------------------------------------------

	yyFindAction:

// [10.0] code to find the action number goes here ---------------------
		yyAct = int(yyAccept[yyCurrentState])
// SKEL ----------------------------------------------------------------

		yy.textPtr = yyBp

// [2.0] code to fiddle yytext and yyleng for yy''more() goes here -------
	yyleng = yyCp - yyBp
// SKEL ----------------------------------------------------------------

		yy.holdChar = yy.chBuf[yyCp]
		yy.chBuf[yyCp] = 0

// [3.0] code to copy yytext_ptr to yytext[] goes here, if %array ------
// SKEL ----------------------------------------------------------------

		yy.cBufP = yyCp
		yytext = yy.chBuf[yy.textPtr:yyCp]
 
// [11.0] code for yylineno update goes here ---------------------------

		if yyAct != yyEndOfBuffer && yyRuleCanMatchEol[yyAct] != 0 {
			for yyl := 0; yyl < yyleng; yyl++ {
				if yytext[yyl] == '\n' {
					yy.Lineno++
				}
			}
		}

// SKEL ----------------------------------------------------------------

	doAction: // This label is used only to access EOF actions.

// [12.0] debug code goes here -----------------------------------------
// SKEL ----------------------------------------------------------------

		switch yyAct { // beginning of action switch

// [13.0] actions go here ----------------------------------------------
			case 0: // must back up
			// undo the effects of yy_DO_BEFORE_ACTION
			yy.chBuf[yyCp] = yy.holdChar
			yyCp = yy.lastAcceptingCpos
			yyCurrentState = yy.lastAcceptingState
			goto yyFindAction

case 1:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)

//line parser/lexer.l:187
{ return yy.Token(_DOT_DOT_);     }
case 2:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:188
{ return yy.Token(_LT_);          }
case 3:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:189
{ return yy.Token(_GT_);          }
case 4:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:190
{ return yy.Token(_LE_);          }
case 5:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:191
{ return yy.Token(_GE_);          }
case 6:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:192
{ return yy.Token(_EQ_);          }
case 7:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:193
{ return yy.Token(_NEQ_);         }
case 8:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:194
{ return yy.Token(_SHIFT_LEFT_);  }
case 9:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:195
{ return yy.Token(_SHIFT_RIGHT_); }
case 10:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:196
{ return yy.Token(_PRIVATE_);     }
case 11:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:197
{ return yy.Token(_GLOBAL_);      }
case 12:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:198
{ return yy.Token(_RULE_);        }
case 13:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:199
{ return yy.Token(_META_);        }
case 14:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:200
{ return yy.Token(_STRINGS_);     }
case 15:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:201
{ return yy.Token(_ASCII_);       }
case 16:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:202
{ return yy.Token(_BASE64_);      }
case 17:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:203
{ return yy.Token(_BASE64WIDE_);  }
case 18:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:204
{ return yy.Token(_WIDE_);        }
case 19:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:205
{ return yy.Token(_XOR_);         }
case 20:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:206
{ return yy.Token(_FULLWORD_);    }
case 21:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:207
{ return yy.Token(_NOCASE_);      }
case 22:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:208
{ return yy.Token(_CONDITION_);   }
case 23:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:209
{ return yy.Token(_TRUE_);        }
case 24:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:210
{ return yy.Token(_FALSE_);       }
case 25:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:211
{ return yy.Token(_NOT_);         }
case 26:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:212
{ return yy.Token(_AND_);         }
case 27:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:213
{ return yy.Token(_OR_);          }
case 28:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:214
{ return yy.Token(_AT_);          }
case 29:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:215
{ return yy.Token(_IN_);          }
case 30:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:216
{ return yy.Token(_OF_);          }
case 31:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:217
{ return yy.Token(_THEM_);        }
case 32:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:218
{ return yy.Token(_FOR_);         }
case 33:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:219
{ return yy.Token(_ALL_);         }
case 34:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:220
{ return yy.Token(_ANY_);         }
case 35:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:221
{ return yy.Token(_NONE_);        }
case 36:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:222
{ return yy.Token(_ENTRYPOINT_);  }
case 37:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:223
{ return yy.Token(_FILESIZE_);    }
case 38:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:224
{ return yy.Token(_MATCHES_);     }
case 39:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:225
{ return yy.Token(_CONTAINS_);    }
case 40:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:226
{ return yy.Token(_ICONTAINS_);   }
case 41:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:227
{ return yy.Token(_STARTSWITH_);  }
case 42:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:228
{ return yy.Token(_ISTARTSWITH_); }
case 43:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:229
{ return yy.Token(_ENDSWITH_);    }
case 44:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:230
{ return yy.Token(_IENDSWITH_);   }
case 45:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:231
{ return yy.Token(_IEQUALS_);     }
case 46:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:232
{ return yy.Token(_IMPORT_);      }
case 47:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:233
{ return yy.Token(_INCLUDE_);     }
case 48:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:234
{ return yy.Token(_DEFINED_);     }
case 49:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:236
{ yy.start = 1 + 2*  (COMMENT);       }
case 50:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:237
{ yy.start = 1 + 2*  (yyInitial );       }
case 51:
/* rule 51 can match eol */

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:238
{ /* skip comments */   }
case 52:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:241
{ /* skip single-line comments */ }
case (yyEndOfBuffer + yyInitial  + 1) :
	fallthrough
case (yyEndOfBuffer + STR + 1) :
	fallthrough
case (yyEndOfBuffer + REGEXP + 1) :
	fallthrough
case (yyEndOfBuffer + COMMENT + 1) :
//line parser/lexer.l:243
{ return yy.Token(eof) }
case 53:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:246
{
  return yy.TokenString(_STRING_IDENTIFIER_WITH_WILDCARD_, yy.Context.Token);
}
case 54:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:251
{
  return yy.TokenString(_STRING_IDENTIFIER_, yy.Context.Token);
}
case 55:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:256
{
  return yy.TokenString(_STRING_COUNT_, yy.Context.Token);
}
case 56:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:261
{
  return yy.TokenString(_STRING_OFFSET_, yy.Context.Token);
}
case 57:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:266
{
  return yy.TokenString(_STRING_LENGTH_, yy.Context.Token);
}
case 58:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:271
{
  return yy.TokenString(_INTEGER_FUNCTION_, yy.Context.Token);
}
case 59:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:276
{
  return yy.TokenString(_IDENTIFIER_, yy.Context.Token);
}
case 60:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:281
{
  s := strings.TrimRight(yy.Context.Token, "MKB")
  v, err := strconv.ParseInt(s, 10, 64)
  if err != nil {
    return Error(
      gyperror.NumberConversionError,
      fmt.Sprintf("%s", err))
  }
  if strings.HasSuffix(yy.Context.Token, "KB") {
      if v > math.MaxInt64 / 1024 {
        return Error(
          gyperror.IntegerOverflowError,
          fmt.Sprintf("Found %s; Max: %d", yy.Context.Token, int64(math.MaxInt64)))
      } else {
        v *= 1024
      }
  } else if strings.HasSuffix(yy.Context.Token, "MB") {
      if v > math.MaxInt64 / 1048576 {
        return Error(
          gyperror.IntegerOverflowError,
          fmt.Sprintf("Found %s; Max: %d", yy.Context.Token, int64(math.MaxInt64)))
      } else {
          v *= 1048576
      }
  }
  return yy.TokenInt64(_NUMBER_, v);
}
case 61:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:309
{
  v, err := strconv.ParseFloat(yy.Context.Token, 64)
  if err != nil {
    return Error(
      gyperror.NumberConversionError,
      fmt.Sprintf("%s", err))
  }
  return yy.TokenFloat64(_DOUBLE_, v);
}
case 62:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:319
{
  v, err := strconv.ParseInt(yy.Context.Token, 0, 64)
  if err != nil {
    return Error(
      gyperror.NumberConversionError,
      fmt.Sprintf("%s", err))
  }
  return yy.TokenInt64(_HEX_NUMBER_, v);
}
case 63:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:329
{
  s := strings.TrimLeft(yy.Context.Token, "0o")
  v, err := strconv.ParseInt(s, 8, 64)
  if err != nil {
    return Error(
      gyperror.NumberConversionError,
      fmt.Sprintf("%s", err))
  }
  return yy.TokenInt64(_OCT_NUMBER_, v);
}
case 64:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:341
{     /* saw closing quote - all done */
  yy.start = 1 + 2*  (yyInitial );
  return yy.TokenString(_TEXT_STRING_, string(str));
}
case 65:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:347
{
  str = append(str, yytext...)
}
case 66:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:352
{
  str = append(str, yytext...)
}
case 67:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:357
{
  str = append(str, yytext...)
}
case 68:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:362
{
  str = append(str, yytext...)
}
case 69:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:367
{
  str = append(str, yytext...)
}
case 70:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:372
{
  str = append(str, yytext...)
}
case 71:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:377
{
  str = append(str, yytext...)
}
case 72:
/* rule 72 can match eol */

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:382
{
  return Error(
    gyperror.UnterminatedStringError,
    "unterminate string")
}
case 73:
/* rule 73 can match eol */

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:389
{
  return Error(
    gyperror.IllegalEscapeSequenceError,
    "illegal escape sequence")
}
case 74:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:396
{
  if err := validateUTF8(string(regexp)); err != nil {
    return Error(gyperror.InvalidUTF8Error, err.Error())
  }

  var mods ast.RegexpModifiers
  for _, c := range yy.Context.Token {
      switch c {
      case 'i':
          mods = mods | ast.RegexpCaseInsensitive
      case 's':
          mods = mods | ast.RegexpDotAll
      case '/':
          // Ignore
      default:
          // Should be impossible
          return Error(
            gyperror.InvalidRegexModifierError,
            fmt.Sprintf(`invalid regexp modifier "%c"`, c))
      }
  }

  yy.start = 1 + 2*  (yyInitial );
  return yy.TokenRegExp(&ast.LiteralRegexp{
     Value: string(regexp),
     Modifiers: mods,
  });
}
case 75:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:426
{
  regexp = append(regexp, yytext...)
}
case 76:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:431
{
  regexp = append(regexp, yytext...)
}
case 77:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:436
{
  regexp = append(regexp, yytext...)
}
case 78:
/* rule 78 can match eol */

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:441
{
  return Error(
    gyperror.UnterminatedRegexError,
    "unterminated regexp")
}
case 79:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:448
{
  str = []byte{}
  yy.start = 1 + 2*  (STR);
}
case 80:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:454
{
  regexp = []byte{}
  yy.start = 1 + 2*  (REGEXP);
}
case 81:
/* rule 81 can match eol */

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:460
{
  // Match hex-digits with whitespace or comments. The latter are stripped
  // out by hex_lexer.l

  // NOTE: The above comment may not apply. We plan to not use hex_lexer.l

  // No need to collect like str and regexp start conditions
  hexTokens, err := hex.Parse(strings.NewReader(yy.Context.Token))
  if err != nil {
    return YYtype{Error: err.(gyperror.Error)}
  }

  return yy.TokenHexString(hexTokens);
}
case 82:
/* rule 82 can match eol */

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:476
/* skip whitespace */
case 83:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:478
{

  r := int(yytext[0])

  if r >= 32 && r < 127 {
    return yy.Token(r)
  }

  return Error(
    gyperror.InvalidAsciiError,
    fmt.Sprintf(`invalid ASCII character "\x%02x"`, r))
}
case 84:

	yylineno = yy.Lineno
	// This code is executed before every lexer action.
  yy.Context.Token = string(yytext)


//line parser/lexer.l:491
yyout.Write(yytext) 
//line parser/lexer.go:1641
// SKEL ----------------------------------------------------------------

		case yyEndOfBuffer:
			/* Amount of text matched not including the EOB char. */
			yyAmountOfMatchedText := yyCp - yy.textPtr - 1

			/* Undo the effects of yy_DO_BEFORE_ACTION. */
			yy.chBuf[yyCp] = yy.holdChar
			 
			if yy.bufferStatus == yyBufferNew {
				/* We're scanning a new file or input source.  It's
				 * possible that this happened because the user
				 * just pointed yyin at a new source and called
				 * yylex().  If so, then we have to assure
				 * consistency between yy_CURRENT_BUFFER and our
				 * globals.  Here is the right place to do so, because
				 * this is the first action (other than possibly a
				 * back-up) that will match for the new input source.
				 */
				yy.nChars = yy.bufNChars
				yy.inputFile = yy.In
				yy.bufferStatus = yyBufferNormal
			}

			/* Note that here we test for yy_c_buf_p "<=" to the position
			 * of the first EOB in the buffer, since yy_c_buf_p will
			 * already have been incremented past the NUL character
			 * (since all states make transitions on EOB to the
			 * end-of-buffer state).  Contrast this with the test
			 * in input().
			 */
			if yy.cBufP <= yy.nChars {
				/* This was really a NUL. */
				var yyNextState int

				yy.cBufP = yy.textPtr + yyAmountOfMatchedText

				yyCurrentState = yy.getPreviousState()

				/* Okay, we're now positioned to make the NUL
				 * transition.  We couldn't have
				 * yy_get_previous_state() go ahead and do it
				 * for us because it doesn't know how to deal
				 * with the possibility of jamming (and we don't
				 * want to build jamming into it because then it
				 * will run more slowly).
				 */

				yyNextState = yy.tryNulTrans(yyCurrentState)

				yyBp = yy.textPtr + 0 

				if yyNextState != 0 {
					/* Consume the NUL. */
					yy.cBufP++
					yyCp = yy.cBufP
					yyCurrentState = yyNextState
					goto yyMatch
				} else {

// [14.0] code to do back-up for compressed tables and set up yy_cp goes here
				yyCp = yy.lastAcceptingCpos
				yyCurrentState = yy.lastAcceptingState
// SKEL ----------------------------------------------------------------

					goto yyFindAction
				}

			} else {

				switch yy.getNextBuffer() {
				case eobActEndOfFile:
					yy.didBufferSwitchOnEof = false

					if yy.Wrap(yy) {
						// Note: because we've taken care in
						// yy_get_next_buffer() to have set up
						// yytext, we can now set up
						// yy.cBufP so that if some total
						// hoser (like flex itself) wants to
						// call the scanner after we return the
						// yy_NULL, it'll still work - another
						// yy_NULL will get returned.
						yy.cBufP = yy.textPtr + 0 

						yyAct = (yyEndOfBuffer + ((yy.start - 1) / 2)  + 1) 
						goto doAction
					} else {
						if !yy.didBufferSwitchOnEof {
							yy.NewFile()
						}
					}
				case eobActContinueScan:
					yy.cBufP = yy.textPtr + yyAmountOfMatchedText

					yyCurrentState = yy.getPreviousState()

					yyCp = yy.cBufP
					yyBp = yy.textPtr + 0 
					goto yyMatch
				case eobActLastMatch:
					yy.cBufP = yy.nChars

					yyCurrentState = yy.getPreviousState()

					yyCp = yy.cBufP
					yyBp = yy.textPtr + 0 
					goto yyFindAction
				}
			}

		default:
			log.Panicln("fatal flex scanner internal error--no action found:", yyAct)
		} // end of action switch
	} // end of scanning one token
	var yyvalue YYtype
	return yyvalue
} // end of yylex

/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
func (yy *Scanner) getNextBuffer() int {

	var numberToMove int
	var retval int

	if yy.cBufP > yy.nChars+1 {
		log.Panic("fatal flex scanner internal error--end of buffer missed")
	}

	if !yy.fillBuffer {
		// Don't try to fill the buffer, so this is an EOF.
		if yy.cBufP-yy.textPtr-0  == 1 {
			// We matched a single character, the EOB, so
			// treat this as a final EOF.
			return eobActEndOfFile
		} else {
			// We matched some text prior to the EOB, first
			// process it.
			return eobActLastMatch
		}
	}

	// Try to read more data.

	// First move last chars to start of buffer.
	numberToMove = yy.cBufP - yy.textPtr - 1

	copy(yy.chBuf, yy.chBuf[yy.textPtr:yy.textPtr+numberToMove])

	if yy.bufferStatus == yyBufferEofPending {
		// don't do the read, it's not guaranteed to return an EOF,
		// just force an EOF
		yy.nChars = 0
		yy.bufNChars = 0
	} else {
		numToRead := yy.bufSize - numberToMove - 1

		for numToRead <= 0 {
			// Not enough room in the buffer - grow it.

			yyCBufPOffset := yy.cBufP

			new_size := yy.bufSize * 2

			if new_size <= 0 {
				yy.bufSize += yy.bufSize / 8
			} else {
				yy.bufSize *= 2
			}

			// Include room in for 2 EOB chars.
			bb := make([]byte, yy.bufSize+2-len(yy.chBuf))
			yy.chBuf = append(yy.chBuf, bb...)

			yy.cBufP = yyCBufPOffset

			numToRead = yy.bufSize - numberToMove - 1

		}

		if numToRead > yyReadBufSize {
			numToRead = yyReadBufSize
		}

		// Read in more data.
		yy.nChars = yy.input(numberToMove, numToRead)
		yy.bufNChars = yy.nChars
	}

	if yy.nChars == 0 {
		if numberToMove == 0  {
			retval = eobActEndOfFile
			yy.Restart(yy.In)
		} else {
			retval = eobActLastMatch
			yy.bufferStatus = yyBufferEofPending
		}
	} else {
		retval = eobActContinueScan
	}

	if yy.nChars+numberToMove > yy.bufSize {
		// Extend the array by 50%, plus the number we really need. *
		newSize := yy.nChars + numberToMove + (yy.nChars >> 1)
		if leng := len(yy.chBuf); leng < newSize {
			chBuf := make([]byte, newSize-leng)
			yy.chBuf = append(yy.chBuf, chBuf...)
		}
	}

	yy.nChars += numberToMove
	//yy.bufNChars += numberToMove // TODO: missing in C skel, bug?
	yy.chBuf[yy.nChars] = yyEndOfBufferChar
	yy.chBuf[yy.nChars+1] = yyEndOfBufferChar

	yy.textPtr = 0

	return retval
}

/* yy_get_previous_state - get the state just before the EOB char was reached */
func (yy *Scanner) getPreviousState() int {

	var yyCurrentState int
	var yyCp int

// [15.0] code to get the start state into yy_current_state goes here --
	yyCurrentState = yy.start
// SKEL ----------------------------------------------------------------

	for yyCp = yy.textPtr + 0 ; yyCp < yy.cBufP; yyCp++ {

// [16.0] code to find the next state goes here ------------------------
		yyC := yyIfElse(yy.chBuf[yyCp] != 0, int(yyEc[yy.chBuf[yyCp]]), 1)
				if yyAccept[yyCurrentState] != 0 {
			yy.lastAcceptingState = yyCurrentState
			yy.lastAcceptingCpos = yyCp
		}
		for int(yyChk[int(yyBase[yyCurrentState])+yyC]) != yyCurrentState {
			yyCurrentState = int(yyDef[yyCurrentState])
			if yyCurrentState >= 288 {
				yyC = int(yyMeta[yyC])
			}
		}
		yyCurrentState = int(yyNxt[int(yyBase[yyCurrentState])+yyC])
// SKEL ----------------------------------------------------------------

	}
	return yyCurrentState
}

/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *      next_state = yy_try_NUL_trans( current_state );
 */
func (yy *Scanner) tryNulTrans(yyCurrentState int) int {

	var yyIsJam bool
	var yyCp int
	_ = yyCp

// [17.0] code to find the next state, and perhaps do backing up, goes here
	yyCp = yy.cBufP

	yyC := 1
		if yyAccept[yyCurrentState] != 0 {
		yy.lastAcceptingState = yyCurrentState
		yy.lastAcceptingCpos = yyCp
	}
	for int(yyChk[int(yyBase[yyCurrentState])+yyC]) != yyCurrentState {
		yyCurrentState = int(yyDef[yyCurrentState])
		if yyCurrentState >= 288 {
			yyC = int(yyMeta[yyC])
		}
	}
	yyCurrentState = int(yyNxt[int(yyBase[yyCurrentState])+yyC])
	if yyCurrentState == 287 {
		yyIsJam = true
	}
// SKEL ----------------------------------------------------------------

	if yyIsJam {
		return 0
	}
	return yyCurrentState
}

func (yy *Scanner) Input() (byte, error) {

	yy.chBuf[yy.cBufP] = yy.holdChar

	if yy.chBuf[yy.cBufP] == yyEndOfBufferChar {
		// yy_c_buf_p now points to the character we want to return.
		// If this occurs *before* the EOB characters, then it's a
		// valid NUL; if not, then we've hit the end of the buffer.
		if yy.cBufP < yy.nChars {
			// This was really a NUL.
			yy.chBuf[yy.cBufP] = 0
		} else {
			// need more input
			offset := yy.cBufP - yy.textPtr
			yy.cBufP++

			switch yy.getNextBuffer() {
			case eobActLastMatch:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
				yy.Restart(yy.In)

				fallthrough

			case eobActEndOfFile:
				if yy.Wrap(yy) {
					return 0, io.EOF
				}

				if !yy.didBufferSwitchOnEof {
					yy.Restart(yy.In)
				}

				return yy.Input()

			case eobActContinueScan:
				yy.cBufP = yy.textPtr + offset
			}
		}
	}

	c := yy.chBuf[yy.cBufP]
	yy.chBuf[yy.cBufP] = 0	// preserve yytext
	yy.cBufP++
	yy.holdChar = yy.chBuf[yy.cBufP]

// [19.0] update BOL and yylineno --------------------------------------
	if c == '\n' {
		yy.Lineno++
	}
// SKEL ----------------------------------------------------------------

return c, nil
}

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c yyInitial  .
 */
func (yy *Scanner) Restart(input_file io.Reader) {
	yy.initBuffer(input_file)
	yy.loadBufferState()
}

func (yy *Scanner) loadBufferState() {
	yy.nChars = yy.bufNChars
	yy.cBufP = yy.bufPos
	yy.textPtr = yy.cBufP
	yy.In = yy.inputFile
	yy.holdChar = yy.chBuf[yy.cBufP]
}

/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
func (yy *Scanner) initBuffer(file io.Reader) {

	yy.flushBuffer()

	yy.inputFile = file

	yy.fillBuffer = true

	yy.Interactive = yy.IsInteractive(file)

}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
func (yy *Scanner) flushBuffer() {

	yy.bufNChars = 0

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	yy.chBuf[0] = yyEndOfBufferChar
	yy.chBuf[1] = yyEndOfBufferChar

	yy.bufPos = 0

	yy.atBol = 1
	yy.bufferStatus = yyBufferNew

	yy.loadBufferState()
}

func yyIfElse(b bool, i1, i2 int) int {
	if b {
		return i1
	}
	return i2
}

func YYmain(filenames ...string) (interface{}, error) {

	var errval error

	yy := NewScanner()

	yy.Filename = "<stdin>"

	if len(filenames) > 0 {
		yy.Filename = filenames[0]
		yy.In, errval = os.Open(yy.Filename)
		if errval != nil {
			return nil, errval
		}
		yy.Wrap = func(yyy *Scanner) bool {
			if len(filenames) == 0 {
				// should not happen
				return true
			}
			yyy.In.(*os.File).Close()
			filenames = filenames[1:]
			if len(filenames) == 0 {
				return true
			}
			yyy.Filename = filenames[0]
			yyy.In, errval = os.Open(yyy.Filename)
			if errval != nil {
				return true
			}
			return false
		}
	}

	return yy.Lex(), errval

}

// END OF SKELL --------------------------------------------------------
//line parser/lexer.l:491



